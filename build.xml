<!--
  ~ Copyright (c) 2012, The Broad Institute
  ~
  ~ Permission is hereby granted, free of charge, to any person
  ~ obtaining a copy of this software and associated documentation
  ~ files (the "Software"), to deal in the Software without
  ~ restriction, including without limitation the rights to use,
  ~ copy, modify, merge, publish, distribute, sublicense, and/or sell
  ~ copies of the Software, and to permit persons to whom the
  ~ Software is furnished to do so, subject to the following
  ~ conditions:
  ~
  ~ The above copyright notice and this permission notice shall be
  ~ included in all copies or substantial portions of the Software.
  ~ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  ~ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  ~ OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  ~ NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  ~ HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  ~ WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  ~ FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  ~ OTHER DEALINGS IN THE SOFTWARE.
  -->

<project name="Sting" default="dist" basedir="." xmlns:ivy="antlib:org.apache.ivy.ant">
    <description>Compile and distribute the Sting toolkit</description>
    <property name="build.sysclasspath" value="first" />

    <property name="build.dir" value="build" />
    <property name="binaries.dir" value="binaries" />
    <property name="dist.dir" value="dist" />
    <property name="contract.dump.dir" value="dump" />
    <property name="pipelinetest.dir" value="pipelinetests" />
    <property name="lib.dir" value="lib" />
    <property name="external.dir" value="external" />
    <property name="public.dir" value="public" />
    <property name="private.dir" value="private" />
    <property name="java.public.source.dir" value="${public.dir}/java/src" />
    <property name="java.private.source.dir" value="${private.dir}/java/src" />
    <property name="java.classes" value="${build.dir}/java/classes" />
    <property name="R.public.scripts.dir" value="${public.dir}/R/scripts" />
    <property name="R.private.scripts.dir" value="${private.dir}/R/scripts" />
    <property name="R.public.src.dir" value="${public.dir}/R/src" />
    <!-- Legacy: Installing libraries back into the source directory
    instead of the build or dist directory... intentionally avoids ant clean?? -->
    <property name="R.library.dir" value="${public.dir}/R" />
    <property name="R.tar.dir" value="${build.dir}/R/src" />
    <property name="R.package.path" value="org/broadinstitute/sting/utils/R" />
    <property name="resource.file" value="StingText.properties" />
    <property name="resource.path" value="${java.classes}/StingText.properties" />
    <property name="key.dir" value="${public.dir}/keys" />

    <property name="scala.public.source.dir" value="${public.dir}/scala/src" />
    <property name="scala.private.source.dir" value="${private.dir}/scala/src" />
    <property name="scala.classes" value="${build.dir}/scala/classes" />

    <property name="queue-extensions.source.dir" value="${build.dir}/queue-extensions/src" />

    <property name="javadoc.dir" value="javadoc" />
    <property name="scaladoc.dir" value="scaladoc" />

    <!-- Contracts for Java -->
    <!-- By default, enabled only for test targets -->
    <!-- To disable for test targets, run with -Duse.contracts=false -->
    <!-- To enable for non-test targets, run with -Duse.contracts=true -->
    <property name="java.contracts" value="${build.dir}/java/contracts" />
    <property name="contracts.version" value="1.0-20110609" />
    <property name="cofoja.jar" value="${lib.dir}/cofoja-${contracts.version}.jar"/>

    <!-- where to find 'findbugs', which you must set if you plan to use 'ant findbugs' -->
    <property name="findbugs.home" value="./findbugs"/>

    <!-- do we want to halt on failure of a unit test? default to yes (Bamboo uses 'no') -->
    <property name="halt" value="yes" />

    <!-- should our unit test output go to a file or the screen?
    false means it goes to the screen (default) true to file -->
    <property name="usefile" value="false" />

    <!-- If running the 'package' task, this property controls the name of the xml file to package -->
    <property name="package.xml.dir" value="${public.dir}/packages" />
    <property name="package.output.dir" value="${dist.dir}/packages" />
    <property name="staging.dir" value="staging" />
    <property name="executable" value="GenomeAnalysisTK" />

    <property environment="env"/>

    <patternset id="java.source.pattern">
        <include name="${java.public.source.dir}/**/*.java" />
        <include name="${java.private.source.dir}/**/*.java" if="include.private" />
    </patternset>

    <fileset id="java.source.files" dir="${basedir}">
        <patternset refid="java.source.pattern" />
    </fileset>

    <!-- terrible hack to get gatkdocs to see all files -->
    <patternset id="all.java.source.pattern">
        <include name="${java.public.source.dir}/**/*.java" />
        <include name="${java.private.source.dir}/**/*.java" />
    </patternset>

    <fileset id="all.java.source.files" dir="${basedir}">
        <patternset refid="all.java.source.pattern" />
    </fileset>

    <fileset id="external.source.files" dir="${external.dir}" erroronmissingdir="false">
        <include name="**/*.java" />
    </fileset>

    <fileset id="java.class.files" dir="${java.classes}" erroronmissingdir="false">
        <include name="**/*.class"/>
    </fileset>

    <!-- the path for resources that need to go into the GATK jar;
         any additional resources should go into this set. -->
    <path id="gatk.resources">
        <fileset dir="${basedir}">
            <include name="${java.public.source.dir}/**/templates/*" />
            <include name="${java.private.source.dir}/**/templates/*" if="include.private" />
        </fileset>
    </path>

    <patternset id="dependency.mask" includes="*.jar">
      <exclude name="testng*.jar" />
      <exclude name="bcel*.jar" />
    </patternset>

    <path id="external.dependencies">
      <fileset dir="${lib.dir}">
        <patternset refid="dependency.mask" />
      </fileset>
    </path>

    <path id="testng.dependencies">
        <fileset dir="${lib.dir}">
            <include name="jcommander*.jar"/>
            <include name="guice*.jar"/>
            <include name="junit*.jar"/>
            <include name="bsh*.jar"/>
            <include name="snakeyaml*.jar"/>
        </fileset>
    </path>

    <path id="build.results">
      <fileset dir="dist">
        <patternset refid="dependency.mask" />
      </fileset>
    </path>

    <!-- Path to scala dependencies. -->
    <path id="scala.dependencies">
        <path refid="external.dependencies" />
        <pathelement location="${java.classes}" />
        <!-- Need the resources as we will be running a command line program which needs the help text. -->
        <pathelement location="${resource.path}" />
        <!-- Add any previously compiled scala classes to the path. -->
        <pathelement location="${scala.classes}" />
    </path>

    <target name="init.resolve" unless="init.resolve.done">
        <!-- ivy properties -->
        <property name="ivy.install.version" value="2.2.0"/>
        <property name="ivy.home" value="${user.home}/.ant"/>
        <property name="ivy.jar.dir" value="${ivy.home}/${lib.dir}"/>
        <property name="ivy.jar.file" value="ivy-${ivy.install.version}.jar"/>
        <property name="ivy.settings.dir" value="settings"/>
        <property file="${ivy.settings.dir}/ivysettings.properties"/>

      <mkdir dir="${lib.dir}"/>
      <mkdir dir="${ivy.jar.dir}"/>

      <!-- Comment out the following two lines to build the GATK without a network connection, assuming you have all of the libraries cached already -->
      <get src="http://repo1.maven.org/maven2/org/apache/ivy/ivy/${ivy.install.version}/${ivy.jar.file}"
           dest="${ivy.jar.dir}/${ivy.jar.file}"
           usetimestamp="true"/>
      <taskdef resource="org/apache/ivy/ant/antlib.xml"
               uri="antlib:org.apache.ivy.ant"
               classpath="${ivy.jar.dir}/${ivy.jar.file}"/>

      <ivy:settings file="${ivy.settings.dir}/ivysettings.xml"/>
        <property name="init.resolve.done" value="true"/>
    </target>

    <target name="resolve" depends="init.resolve,init"
            description="locate and download library dependencies">
        <property name="ivy.conf" value="default"/>
      <ivy:retrieve file="ivy.xml" conf="${ivy.conf}" />
      <!-- Remove old versions of ivy jars AFTER the ivy:retrieve has been class loaded. -->
      <delete file="${ivy.jar.dir}/ivy-2.0.0.jar"/>
      <delete file="${ivy.jar.dir}/ivy-2.2.0-rc1.jar"/>
      <!--
         An old versions of the ivy-1.4.1.xml does not contain /ivy-module/configuration/conf/@name="compile".
         Easier to upgrade to 1.4.4 than try to deal with xmlproperty and conditional deletion in ant.
         Just in case we remove explicit 1.4.4 and go back to 1.4.1, try to clean out the file for now.
        -->
      <delete file="${ivy.home}/cache/javax.mail/mail/ivy-1.4.1.xml"/>
      <delete file="${ivy.home}/cache/javax.mail/mail/ivydata-1.4.1.properties"/>
      <delete file="${ivy.home}/cache/javax.mail/mail/jars/mail-1.4.1.jar"/>
    </target>

    <target name="init.buildall">
        <!-- Set the properties needed to build everything -->
        <property name="gatk.target" value="private"/>
        <property name="scala.target" value="core"/>
    </target>

    <target name="init.buildpublic">
        <!-- Set the properties needed to build public only -->
        <property name="gatk.target" value="core"/>
        <property name="scala.target" value="core"/>
    </target>

    <target name="init.usecontracts">
        <property name="use.contracts" value="true" />
    </target>

    <target name="git.describe">
      <exec executable="git" outputproperty="git.describe.output" resultproperty="git.describe.exit.value" failonerror="false">
        <arg line="describe --long" />
      </exec>
      <condition property="git.describe.succeeded">
        <equals arg1="${git.describe.exit.value}" arg2="0" />
      </condition>
    </target>

    <target name="tagged.build.version" depends="git.describe" if="git.describe.succeeded">
        <property name="build.version" value="${git.describe.output}" />
    </target>

    <target name="git.rev-parse" depends="git.describe" unless="git.describe.succeeded">
      <exec executable="git" outputproperty="git.rev-parse.output" resultproperty="git.rev-parse.exit.value" failonerror="false">
        <arg line="rev-parse HEAD" />
      </exec>
      <condition property="git.rev-parse.succeeded">
        <equals arg1="${git.rev-parse.exit.value}" arg2="0" />
      </condition>
    </target>

    <target name="untagged.build.version" depends="git.rev-parse" if="git.rev-parse.succeeded">
        <property name="build.version" value="${git.rev-parse.output}" />
    </target>

    <target name="generate.build.version" depends="tagged.build.version, untagged.build.version">
        <!-- Set build.version to exported if no other value has been set -->
        <property name="build.version" value="exported" />
    </target>

    <!-- define some key locations that might change based on how the build is run -->
    <target name="init" depends="generate.build.version">
      <tstamp>
        <format property="build.timestamp" pattern="yyyy/MM/dd HH:mm:ss"/>
      </tstamp>

        <!-- Set target based on STING_BUILD_TYPE environment variable -->
        <condition property="sting.target" value="core" else="${env.STING_BUILD_TYPE}">
            <equals arg1="${env.STING_BUILD_TYPE}" arg2="$${env.STING_BUILD_TYPE}" />
        </condition>

        <!-- Get the gatk build target.  Default to the STING_BUILD_TYPE.  -->
        <condition property="gatk.target" value="${sting.target}" else="${env.GATK_BUILD_TYPE}">
            <equals arg1="${env.GATK_BUILD_TYPE}" arg2="$${env.GATK_BUILD_TYPE}" />
        </condition>

        <!-- Get the queue build target.  Default to none.  -->
        <condition property="scala.target" value="none" else="${env.QUEUE_BUILD_TYPE}">
            <equals arg1="${env.QUEUE_BUILD_TYPE}" arg2="$${env.QUEUE_BUILD_TYPE}" />
        </condition>

        <!-- If the scala target is set, then include all scala tasks. -->
        <condition property="scala.include">
            <or>
                <not><equals arg1="${scala.target}" arg2="none" /></not>
            </or>
        </condition>

        <echo message="GATK build      : ${gatk.target}"/>
        <echo message="Scala build     : ${scala.target}"/>
      <echo message="source revision : ${build.version}"/>
      <echo message="build time      : ${build.timestamp}" />

      <condition property="include.private">
        <equals arg1="${gatk.target}" arg2="private" casesensitive="false" />
      </condition>

      <condition property="include.external">
          <available file="${external.dir}"/>
      </condition>

      <condition property="include.contracts">
        <equals arg1="${use.contracts}" arg2="true" />
      </condition>

      <!-- Create the build directory structure used by compile -->
      <mkdir dir="${build.dir}"/>
      <mkdir dir="${binaries.dir}"/>
      <mkdir dir="${lib.dir}"/>
      <mkdir dir="${java.classes}"/>
      <mkdir dir="${java.contracts}"/>

      <pathconvert property="external.build.dir">
        <path path="${java.classes}"/>
      </pathconvert>

      <pathconvert property="external.dist.dir">
        <path path="${dist.dir}" />
      </pathconvert>

      <!-- GATK dependencies consist of 3rd party plugins plus compiled GATK classes -->
      <pathconvert property="external.gatk.classpath">
        <path path="${java.classes}"/>
        <path refid="external.dependencies" />
      </pathconvert>
    </target>

    <target name="init.scala.compile" depends="resolve"
            description="Initializes the scala ant tasks from scala-compiler.jar">
        <path id="scala.classpath">
            <fileset dir="${lib.dir}">
                <include name="scala-compiler-*.jar"/>
                <include name="scala-library-*.jar"/>
            </fileset>
        </path>
        <taskdef resource="scala/tools/ant/antlib.xml">
            <classpath refid="scala.classpath"/>
        </taskdef>
    </target>

    <target name="gatk.compile.public.source" depends="init,resolve">
        <javac fork="true" srcdir="${java.public.source.dir}" memoryMaximumSize="512m" destdir="${java.classes}" debug="true" debuglevel="lines,vars,source" classpathref="external.dependencies" tempdir="${java.io.tmpdir}">
          <compilerarg value="-proc:none"/>
        </javac>
    </target>

    <target name="gatk.compile.private.source" depends="gatk.compile.public.source" if="include.private">
        <javac fork="true" srcdir="${java.private.source.dir}" memoryMaximumSize="512m" destdir="${java.classes}" debug="true" debuglevel="lines,vars,source" classpathref="external.dependencies" tempdir="${java.io.tmpdir}">
          <compilerarg value="-proc:none"/>
        </javac>
    </target>

    <target name="gatk.compile.external.source" depends="gatk.compile.public.source,gatk.compile.private.source" if="include.external">
        <subant target="compile" genericantfile="build.xml">
            <property name="build.dir" value="${external.build.dir}" />
            <property name="dist.dir" value="${external.dist.dir}" />
            <property name="gatk.classpath" value="${external.gatk.classpath}" />
            <fileset dir="${external.dir}" includes="*/build.xml" erroronmissingdir="false" />
        </subant>
    </target>

    <target name="gatk.compile.source"
            depends="gatk.compile.public.source,gatk.compile.private.source,gatk.compile.external.source"
            description="compile the GATK source" />

   <target name="gatk.contracts.public" depends="gatk.compile.source" if="include.contracts">
        <javac fork="true" memoryMaximumSize="512m" srcdir="${java.public.source.dir}" destdir="${java.contracts}" debug="true" debuglevel="lines,vars,source" tempdir="${java.io.tmpdir}" >
            <classpath>
                <path refid="external.dependencies" />
                <pathelement path="${java.classes}" />
            </classpath>
            <compilerarg value="-Acom.google.java.contract.debug"/>
            <compilerarg value="-Acom.google.java.contract.dump=${contract.dump.dir}"/>
            <compilerarg value="-proc:only"/>
        </javac>
   </target>

    <target name="check.contracts.private" depends="gatk.contracts.public">
        <condition property="include.contracts.private">
          <and>
            <isset property="include.contracts" />
            <isset property="include.private" />
          </and>
        </condition>
    </target>

   <target name="gatk.contracts.private" depends="check.contracts.private" if="include.contracts.private">
        <javac fork="true" memoryMaximumSize="512m" srcdir="${java.private.source.dir}" destdir="${java.contracts}" debug="true" debuglevel="lines,vars,source" tempdir="${java.io.tmpdir}" >
            <classpath>
                <path refid="external.dependencies" />
                <pathelement path="${java.classes}" />
            </classpath>
            <compilerarg value="-Acom.google.java.contract.debug"/>
            <compilerarg value="-Acom.google.java.contract.dump=${contract.dump.dir}"/>
            <compilerarg value="-proc:only"/>
        </javac>
   </target>

    <target name="gatk.contracts" depends="gatk.contracts.public,gatk.contracts.private"
            description="create GATK contracts" if="include.contracts" />

    <target name="gatk.compile" depends="init,resolve,gatk.compile.source,gatk.contracts" />

    <target name="init.queue-extensions.generate" depends="gatk.compile">
        <condition property="uptodate.queue-extensions.generate">
            <or>
                <not>
                    <isset property="scala.include"/>
                </not>
                <uptodate targetfile="${queue-extensions.source.dir}">
                    <srcfiles refid="java.class.files"/>
                    <srcfiles file="${queue-extensions.gatk.jar}"/>
                </uptodate>
            </or>
        </condition>
    </target>

    <!-- NOTE: Extracting help first to avoid "Unable to load help text.  Help output will be sparse." warning message. -->
    <target name="queue-extensions.generate" depends="extracthelp,init.queue-extensions.generate" unless="uptodate.queue-extensions.generate" description="generate GATK modules for Queue">
        <mkdir dir="${queue-extensions.source.dir}"/>
        <echo>Generating Queue GATK extensions...</echo>
        <java fork="true" failonerror="true" classname="org.broadinstitute.sting.queue.extensions.gatk.GATKExtensionsGenerator" >
            <arg value="-outDir" />
            <arg path="${queue-extensions.source.dir}" />
            <arg value="-l" />
            <arg value="WARN" />
            <classpath>
                <file file="${queue-extensions.gatk.jar}"/>
                <path refid="scala.dependencies"/>
            </classpath>
        </java>
        <touch>
            <file file="${queue-extensions.source.dir}"/>
        </touch>
    </target>

    <!-- Scala depends on the java compile -->
    <target name="scala.compile.public" depends="init,resolve,gatk.compile,queue-extensions.generate,init.scala.compile" if="scala.include">
        <mkdir dir="${scala.classes}"/>
        <echo>Building Scala...</echo>
        <scalac fork="true" jvmargs="-Xmx512m" destdir="${scala.classes}" classpathref="scala.dependencies" deprecation="yes" unchecked="yes">
            <src path="${scala.public.source.dir}" />
            <src path="${queue-extensions.source.dir}" />
            <include name="**/*.scala"/>
        </scalac>
    </target>

    <target name="check.scala.private" depends="scala.compile.public">
        <condition property="include.scala.private">
          <and>
            <isset property="include.private" />
            <isset property="scala.include" />
          </and>
        </condition>
    </target>

    <target name="scala.compile.private" depends="check.scala.private" if="include.scala.private">
        <scalac fork="true" jvmargs="-Xmx512m" destdir="${scala.classes}" classpathref="scala.dependencies" deprecation="yes" unchecked="yes">
            <src path="${scala.private.source.dir}" />
            <include name="**/*.scala"/>
        </scalac>
    </target>

    <target name="scala.compile" depends="scala.compile.public,scala.compile.private" if="scala.include" description="compile Scala" />

    <target name="init.extracthelp" depends="gatk.compile">
        <loadfile property="properties.version" srcfile="${basedir}/${resource.path}" failonerror="false" quiet="true">
            <filterchain>
                <linecontains>
                    <contains value="org.broadinstitute.sting.gatk.CommandLineGATK.version"/>
                </linecontains>
                <tokenfilter>
                    <replaceregex pattern="^.*\.(.*?)$" replace="\1"/>
                </tokenfilter>
                <striplinebreaks/>
            </filterchain>
        </loadfile>

        <!-- This fileset will contain only source files modified since the resource file was last generated,
             or all source files if the resource file doesn't exist -->
        <fileset dir="${basedir}" id="modified.source.files">
            <patternset refid="java.source.pattern" />
            <include name="${external.dir}/**/*.java"/>
            <depend targetdir="${basedir}">
                <mapper type="merge" to="${resource.path}"/>
            </depend>
        </fileset>

        <!-- Set the sources.modified property only if our fileset of modified source files is non-empty -->
        <pathconvert refid="modified.source.files" property="sources.modified" setonempty="false"/>

        <!-- Due to a limitation in the doclet API, we always need to pass package-info files to javadoc -->
        <fileset dir="${basedir}" id="package.info.files">
            <include name="${java.public.source.dir}/**/package-info.java"/>
            <include name="${java.private.source.dir}/**/package-info.java" if="include.private" />
            <include name="${external.dir}/**/package-info.java"/>
        </fileset>

        <condition property="uptodate.extracthelp">
            <or>
                <isset property="disable.help"/>
                <and>
                    <not>
                        <isset property="sources.modified"/>
                    </not>
                    <equals arg1="${properties.version}" arg2="${build.version}"/>
                </and>
            </or>
        </condition>
    </target>

    <target name="extracthelp" depends="init.extracthelp" unless="uptodate.extracthelp"
	        description="Extract help key/value pair file from the JavaDoc tags.">
        <path id="doclet.classpath">
            <path refid="external.dependencies" />
            <pathelement location="${java.classes}" />
        </path>

        <javadoc doclet="org.broadinstitute.sting.utils.help.ResourceBundleExtractorDoclet"
                 docletpathref="doclet.classpath"
                 classpathref="external.dependencies"
                 classpath="${java.classes}"
                 additionalparam="-build-timestamp &quot;${build.timestamp}&quot; -absolute-version ${build.version} -out ${basedir}/${resource.path} -quiet">
            <sourcefiles>
                <union>
                    <fileset refid="modified.source.files"/>
                    <fileset refid="package.info.files"/>
                </union>
            </sourcefiles>
        </javadoc>
    </target>

    <target name="clean.gatkdocs">
        <delete dir="gatkdocs"/>
    </target>

    <target name="gatkdocs" depends="gatk.compile"
	        description="Extract help key/value pair file from the JavaDoc tags.">
        <path id="doclet.classpath">
            <path refid="external.dependencies" />
            <pathelement location="${java.classes}" />
        </path>

        <!-- Run with -Dgatkdocs.include.hidden=true to include documentation for hidden features -->
        <condition property="gatkdocs.include.hidden.arg" value="-include-hidden" else="">
            <isset property="gatkdocs.include.hidden" />
        </condition>

        <javadoc doclet="org.broadinstitute.sting.utils.help.GATKDoclet"
                 docletpathref="doclet.classpath"
                 classpathref="external.dependencies"
                 classpath="${java.classes}"
                 additionalparam="${gatkdocs.include.hidden.arg} -private -build-timestamp &quot;${build.timestamp}&quot; -absolute-version ${build.version} -quiet"> <!-- -test to only do DocumentationTest walker -->
            <sourcefiles>
                <union>
                    <fileset refid="all.java.source.files"/>
                </union>
            </sourcefiles>
        </javadoc>
    </target>

    <target name="sting.compile" depends="gatk.compile, scala.compile" />

    <target name="R.public.tar">
        <mkdir dir="${R.tar.dir}/${R.package.path}" />
        <tar compression="gzip" basedir="${R.public.src.dir}/${R.package.path}" includes="gsalib/**" destfile="${R.tar.dir}/${R.package.path}/gsalib.tar.gz" />
    </target>

    <target name="init.jar" depends="sting.compile,extracthelp">
        <mkdir dir="${dist.dir}"/>
        <copy todir="${dist.dir}">
            <fileset dir="${lib.dir}" includes="*.jar"/>
        </copy>
    </target>

    <target name="sting-utils.jar" depends="gatk.compile, init.jar, R.public.tar">
        <jar jarfile="${dist.dir}/StingUtils.jar">
            <fileset dir="${java.classes}">
              <include name="**/utils/**/*.class"/>
              <exclude name="**/utils/codecs/vcf/**/*.class"/>
              <exclude name="**/utils/variantcontext/**/*.class"/>
            </fileset>
            <fileset dir="${java.classes}" includes="**/commandline/**/*.class"/>
            <fileset dir="${java.classes}" includes="**/sting/pipeline/**/*.class"/>
            <fileset dir="${java.classes}" includes="**/sting/tools/**/*.class"/>
            <fileset dir="${java.classes}" includes="**/sting/jna/**/*.class"/>
            <fileset dir="${java.classes}" includes="net/sf/picard/**/*.class"/>
            <fileset dir="${java.classes}" includes="net/sf/samtools/**/*.class"/>
            <fileset dir="${R.tar.dir}">
                <include name="**/${R.package.path}/**/*.tar.gz"/>
            </fileset>
            <fileset dir="${R.public.scripts.dir}">
              <include name="**/utils/**/*.R"/>
            </fileset>
            <fileset dir="${R.private.scripts.dir}" erroronmissingdir="false">
              <include name="**/utils/**/*.R"/>
            </fileset>
            <manifest>
                <attribute name="Premain-Class" value="org.broadinstitute.sting.utils.instrumentation.Sizeof" />
            </manifest>
        </jar>
    </target>

    <target name="vcf.jar" depends="gatk.compile,init.jar">
        <jar jarfile="${dist.dir}/vcf.jar">
            <fileset dir="${java.classes}">
              <include name="org/broadinstitute/sting/utils/codecs/vcf/**/*.class"/>
              <include name="org/broadinstitute/sting/utils/variantcontext/**/*.class"/>
              <include name="org/broadinstitute/sting/gatk/refdata/SelfScopingFeatureCodec.class"/>
              <include name="org/broadinstitute/sting/utils/exceptions/**"/>
	      <include name="org/broadinstitute/sting/utils/help/DocumentedGATKFeature.class"/>
            </fileset>
        </jar>
    </target>

    <target name="gatk.jar" depends="gatk.compile, init.jar"
            description="generate the GATK distribution">
        <jar jarfile="${dist.dir}/GenomeAnalysisTK.jar">
            <path refid="gatk.resources"/>
            <fileset dir="${java.contracts}" />
            <fileset dir="${java.classes}">
	          <include name="${resource.file}" />
              <include name="**/gatk/**/*.class" />
              <include name="**/alignment/**/*.class"/>
            </fileset>
            <fileset dir="${R.public.scripts.dir}">
                <include name="**/gatk/**/*.R"/>
                <include name="**/alignment/**/*.R"/>
            </fileset>
            <fileset dir="${R.private.scripts.dir}" erroronmissingdir="false">
                <include name="**/gatk/**/*.R"/>
                <include name="**/alignment/**/*.R"/>
            </fileset>
            <fileset dir="${key.dir}">
                <include name="**/*.key"/>
            </fileset>
            <manifest>
                <attribute name="Main-Class"
                    value="org.broadinstitute.sting.gatk.CommandLineGATK"/>
            </manifest>
        </jar>

        <jar jarfile="${dist.dir}/Aligner.jar">
            <fileset dir="${java.classes}" includes="**/alignment/**/*.class" />
        </jar>

        <jar jarfile="${dist.dir}/AnalyzeCovariates.jar" whenmanifestonly="skip">
          <fileset dir="${java.classes}">
            <include name="**/analyzecovariates/**/*.class" />
            <include name="**/gatk/walkers/recalibration/*.class" />
          </fileset>
            <fileset dir="${R.public.scripts.dir}">
                <include name="**/analyzecovariates/**/*.R"/>
                <include name="**/gatk/walkers/recalibration/**/*.R"/>
            </fileset>
            <fileset dir="${R.private.scripts.dir}" erroronmissingdir="false">
                <include name="**/analyzecovariates/**/*.R"/>
                <include name="**/gatk/walkers/recalibration/**/*.R"/>
            </fileset>
          <manifest>
            <attribute name="Main-Class" value="org.broadinstitute.sting.analyzecovariates.AnalyzeCovariates" />
          </manifest>
        </jar>

        <subant target="dist" genericantfile="build.xml">
            <property name="build.dir" value="${external.build.dir}" />
            <property name="dist.dir" value="${external.dist.dir}" />
            <property name="gatk.classpath" value="${external.gatk.classpath}" />
            <fileset dir="${external.dir}" includes="*/build.xml" erroronmissingdir="false" />
        </subant>
    </target>

    <target name="scala.jar" depends="scala.compile, init.jar" if="scala.include">
        <jar jarfile="${dist.dir}/GATKScala.jar">
          <fileset dir="${scala.classes}">
            <include name="org/broadinstitute/sting/scala/**/*.class"/>
          </fileset>
        </jar>
    </target>

    <target name="queue.jar" depends="scala.compile, init.jar" if="scala.include">
        <jar jarfile="${dist.dir}/Queue.jar">
            <fileset dir="${scala.classes}">
                <include name="org/broadinstitute/sting/queue/**/*.class"/>
            </fileset>
            <fileset dir="${java.classes}">
              <include name="org/broadinstitute/sting/queue/**/*.class" />
            </fileset>
            <fileset dir="${R.public.scripts.dir}">
                <include name="org/broadinstitute/sting/queue/**/*.R"/>
            </fileset>
            <fileset dir="${R.private.scripts.dir}" erroronmissingdir="false">
                <include name="org/broadinstitute/sting/queue/**/*.R"/>
            </fileset>
            <manifest>
                <attribute name="Main-Class" value="org.broadinstitute.sting.queue.QCommandLine" />
            </manifest>
        </jar>
    </target>

    <target name="sting.jar" depends="sting-utils.jar, vcf.jar, gatk.jar, queue.jar" />

    <target name="init.manifests" depends="sting.jar">
        <pathconvert property="jar.classpath" pathsep=" ">
            <flattenmapper/>
            <fileset dir="${dist.dir}" includes="*.jar"/>
            <filelist files="GATKScala.jar"/>
        </pathconvert>
    </target>

    <target name="sting-utils.manifests" depends="sting-utils.jar, init.manifests">
        <jar jarfile="${dist.dir}/StingUtils.jar" update="true">
            <manifest>
                <attribute name="Class-Path" value="${jar.classpath}"/>
            </manifest>
        </jar>
    </target>

    <target name="gatk.manifests" depends="gatk.jar, init.manifests">

        <jar jarfile="${dist.dir}/GenomeAnalysisTK.jar" update="true">
            <manifest>
                <attribute name="Class-Path" value="${jar.classpath}"/>
            </manifest>
        </jar>

        <jar jarfile="${dist.dir}/AnalyzeCovariates.jar" update="true" whenmanifestonly="skip">
            <manifest>
                <attribute name="Class-Path" value="${jar.classpath}" />
            </manifest>
        </jar>

    </target>

    <target name="queue.manifests" depends="queue.jar, init.manifests" if="scala.include">
        <jar jarfile="${dist.dir}/Queue.jar" update="true" >
            <manifest>
                <attribute name="Class-Path" value="${jar.classpath}" />
            </manifest>
        </jar>
    </target>

    <target name="sting.manifests" depends="sting-utils.manifests, gatk.manifests, queue.manifests" />

    <target name="dist" depends="sting.manifests, binary.manifests" />

    <target name="core" description="force a build of the Sting core code">
        <antcall target="dist" inheritAll="false">
            <param name="sting.target" value="core" />
        </antcall>
    </target>

    <target name="private" description="force a build of the Sting private code">
      <antcall target="dist" inheritAll="false">
        <param name="sting.target" value="private" />
	  </antcall>
    </target>

    <target name="queue" description="force a build of Queue">
        <!--
        inheritAll is false so that 'ant queue' does not accidentally import
        params if the build was called with 'ant clean oneoffs queue'.
        Instead this task resets the parameters and is just like running
        a fresh 'ant dist -Dscala.target=core'.
        -->
        <antcall target="dist" inheritAll="false">
            <param name="scala.target" value="core" />
        </antcall>
    </target>

    <!-- new scala target -->
    
    <target name="scala" description="build the scala directory">
        <antcall target="scala.jar" inheritAll="false">
            <param name="scala.target" value="core" />
        </antcall>
    </target>
    
    <!-- ***************************************************************************** -->
    <!-- ***********               Tests and associated tasks                ********* -->
    <!-- ***************************************************************************** -->
    <!-- where to put reports and tests-->
    <property name="report" value="${build.dir}/report"/>
    <property name="test.output" value="${dist.dir}/test"/>
    <property name="java.test.classes" value="${build.dir}/java/testclasses"/>
    <property name="java.public.test.classes" value="${java.test.classes}/public"/>
    <property name="java.private.test.classes" value="${java.test.classes}/private"/>
    <property name="java.external.test.classes" value="${java.test.classes}/external"/>
    <property name="java.public.test.sources" value="${public.dir}/java/test"/>
    <property name="java.private.test.sources" value="${private.dir}/java/test"/>
    <property name="scala.test.classes" value="${build.dir}/scala/testclasses"/>
    <property name="scala.public.test.classes" value="${scala.test.classes}/public"/>
    <property name="scala.private.test.classes" value="${scala.test.classes}/private"/>
    <property name="scala.public.test.sources" value="${public.dir}/scala/test"/>
    <property name="scala.private.test.sources" value="${private.dir}/scala/test"/>
    <property name="testng.jar" value="${lib.dir}/testng-5.14.1.jar"/>
    <!-- provide a ceiling on the memory that unit/integration tests can consume. -->
    <property name="test.maxmemory" value="4g"/>

    <target name="test.init.compile">
        <mkdir dir="${java.test.classes}"/>
        <mkdir dir="${scala.test.classes}"/>
        <antcall target="resolve">
          <param name="ivy.conf" value="test"/>
        </antcall>
    </target>

   <target name="test.java.public.compile" depends="dist,test.init.compile">
        <mkdir dir="${java.public.test.classes}"/>
        <echo message="Sting: Compiling public test cases!"/>
        <javac fork="true" memoryMaximumSize="512m" destdir="${java.public.test.classes}" debug="true" optimize="on" tempdir="${java.io.tmpdir}">
            <src path="${java.public.test.sources}"/>
            <classpath>
                <path refid="external.dependencies" />
                <pathelement location="${java.classes}"/>
                <pathelement location="${java.contracts}"/>
                <pathelement location="${testng.jar}"/>
            </classpath>
            <compilerarg value="-proc:none"/>
        </javac>
    </target>

    <target name="test.java.private.compile" depends="dist,test.init.compile,test.java.public.compile" if="include.private">
        <mkdir dir="${java.private.test.classes}"/>
        <echo message="Sting: Compiling private test cases!"/>
        <javac fork="true" memoryMaximumSize="512m" destdir="${java.private.test.classes}" debug="true" optimize="on" tempdir="${java.io.tmpdir}">
            <src path="${java.private.test.sources}"/>
            <classpath>
                <path refid="external.dependencies" />
                <pathelement location="${java.public.test.classes}"/>
                <pathelement location="${java.classes}"/>
                <pathelement location="${java.contracts}"/>
                <pathelement location="${testng.jar}"/>
            </classpath>
            <compilerarg value="-proc:none"/>
        </javac>
    </target>

    <target name="test.java.external.compile" depends="dist,test.init.compile,test.java.public.compile" if="include.external">
        <mkdir dir="${java.external.test.classes}"/>
        <echo message="Sting: Compiling external test cases!"/>
        <javac fork="true" memoryMaximumSize="512m" destdir="${java.external.test.classes}" debug="true" optimize="on" tempdir="${java.io.tmpdir}" srcdir="${external.dir}">
            <include name="*/test/**/*.java"/>
            <classpath>
                <path refid="external.dependencies" />
                <pathelement location="${java.public.test.classes}"/>
                <pathelement location="${java.classes}"/>
                <pathelement location="${java.contracts}"/>
                <pathelement location="${testng.jar}"/>
            </classpath>
            <compilerarg value="-proc:none"/>
        </javac>
    </target>

    <target name="test.java.compile" depends="test.java.public.compile, test.java.private.compile, test.java.external.compile"/>

    <target name="test.scala.public.compile" depends="test.java.compile,scala.compile" if="scala.include">
        <mkdir dir="${scala.public.test.classes}"/>
        <echo message="Scala: Compiling public test cases!"/>
        <scalac fork="true" jvmargs="-Xmx512m" destdir="${scala.public.test.classes}" deprecation="yes" unchecked="yes">
	        <src path="${scala.public.test.sources}" />
            <classpath>
                <path refid="scala.dependencies"/>
                <pathelement location="${java.public.test.classes}"/>
                <pathelement location="${testng.jar}"/>
            </classpath>
        </scalac>
    </target>

    <target name="test.scala.private.compile" depends="test.java.compile,scala.compile,test.scala.public.compile" if="include.scala.private">
        <mkdir dir="${scala.private.test.classes}"/>
        <echo message="Scala: Compiling private test cases!"/>
        <scalac fork="true" jvmargs="-Xmx512m" destdir="${scala.private.test.classes}" deprecation="yes" unchecked="yes">
	        <src path="${scala.private.test.sources}" />
            <classpath>
                <path refid="scala.dependencies"/>
                <pathelement location="${scala.public.test.classes}"/>
                <pathelement location="${java.public.test.classes}"/>
                <pathelement location="${java.private.test.classes}"/>
                <pathelement location="${testng.jar}"/>
            </classpath>
        </scalac>
    </target>

    <target name="test.scala.compile" depends="test.scala.public.compile,test.scala.private.compile"/>

    <target name="test.compile" depends="init.usecontracts,test.java.compile,test.scala.compile" />


    <path id="testng.default.classpath">
        <pathelement location="${java.classes}" />
        <pathelement location="${scala.classes}" />
        <pathelement location="${java.contracts}" />
        <pathelement location="${java.public.test.classes}" />
        <pathelement location="${java.private.test.classes}" />
        <pathelement location="${java.external.test.classes}" />
        <pathelement location="${scala.public.test.classes}" />
        <pathelement location="${scala.private.test.classes}" />
        <pathelement location="${R.tar.dir}" />
        <pathelement location="${R.public.scripts.dir}" />
        <pathelement location="${R.private.scripts.dir}" />
        <pathelement location="${key.dir}" />
        <path refid="external.dependencies" />
    </path>

    <path id="testng.gatk.releasetest.classpath">
        <path refid="testng.dependencies" />
        <path>
            <fileset dir="${package.output.dir}">
                <include name="**/${executable}.jar" />
            </fileset>
        </path>
        <pathelement location="${java.contracts}" />
        <pathelement location="${java.public.test.classes}" />
        <pathelement location="${scala.public.test.classes}" />
        <pathelement location="${scala.classes}" />
        <path>
            <fileset dir="${lib.dir}">
                <include name="scala*.jar"/>
                <include name="jna*.jar"/>
            </fileset>
        </path>
    </path>

    <path id="testng.queue.releasetest.classpath">
        <path refid="testng.dependencies" />
        <path>
            <fileset dir="${package.output.dir}">
                <include name="**/${executable}.jar" />
            </fileset>
        </path>
        <pathelement location="${java.contracts}" />
        <pathelement location="${java.public.test.classes}" />
        <pathelement location="${scala.public.test.classes}" />
    </path>

    <!-- TEST -->
    <macrodef name="run-test">
        <attribute name="testtype"/>
        <attribute name="outputdir"/>
        <attribute name="classpath"/>
        <attribute name="runfailed"/>

        <sequential>
            <condition property="run.failed.tests">
                <equals arg1="@{runfailed}" arg2="true"/>
            </condition>

            <!-- Get the pipeline run type.  Default to dry.  -->
            <condition property="pipeline.run" value="dry" else="${pipeline.run}">
                <equals arg1="${pipeline.run}" arg2="$${pipeline.run}" />
            </condition>

            <condition property="cofoja.jvm.args" value="-javaagent:${cofoja.jar} -Dcom.google.java.contract.log.contract=false" else="">
                <isset property="include.contracts" />
            </condition>

            <mkdir dir="@{outputdir}"/>
            <echo message="Sting: Running @{testtype} test cases!"/>
            <taskdef resource="testngtasks" classpath="${testng.jar}"/>
            <testng outputDir="@{outputdir}"
                    classpathref="@{classpath}"
                    haltOnFailure="false" failureProperty="test.failure"
                    verbose="2"
                    workingDir="${basedir}"
                    useDefaultListeners="false"
                    listeners="org.testng.reporters.FailedReporter,org.testng.reporters.JUnitXMLReporter,org.broadinstitute.sting.StingTextReporter">
                <jvmarg value="-Xmx${test.maxmemory}" />
                <jvmarg value="-Djava.awt.headless=true" />
                <jvmarg value="-Dpipeline.run=${pipeline.run}" />
                <jvmarg value="-Djava.io.tmpdir=${java.io.tmpdir}" />
                <jvmarg line="${cofoja.jvm.args}"/>
<!--                 <jvmarg value="-Xdebug"/>  -->
<!--                 <jvmarg value="-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"/>   -->

                <classfileset dir="${java.public.test.classes}" includes="**/@{testtype}.class"/>
                <classfileset dir="${java.private.test.classes}" erroronmissingdir="false">
                    <include name="**/@{testtype}.class" if="include.private"/>
                </classfileset>
                <classfileset dir="${java.external.test.classes}" erroronmissingdir="false">
                    <include name="**/@{testtype}.class" if="include.external"/>
                </classfileset>
                <classfileset dir="${scala.public.test.classes}" erroronmissingdir="false">
                    <include name="**/@{testtype}*.class" if="scala.include"/>
                </classfileset>
                <classfileset dir="${scala.private.test.classes}" erroronmissingdir="false">
                    <include name="**/@{testtype}*.class" if="include.scala.private"/>
                </classfileset>

                <xmlfileset dir="${basedir}">
                    <include name="@{testtype}" if="run.failed.tests"/>
                </xmlfileset>
            </testng>

            <!-- generate a report for Bamboo or Hudson to read in -->
            <junitreport todir="@{outputdir}">
                <fileset dir="@{outputdir}">
                    <include name="*/*.xml"/>
                </fileset>
                <report format="noframes" todir="@{outputdir}"/>
            </junitreport>

            <fail message="test failed" if="test.failure" />
        </sequential>
    </macrodef>

    <target name="test.init">
        <property name="testng.classpath" value="testng.default.classpath" />
    </target>

    <target name="committests">
        <antcall target="test" inheritAll="false"/>
        <antcall target="integrationtest" inheritAll="false"/>
        <antcall target="pipelinetest" inheritAll="false"/>
    </target>

    <target name="committests.public">
        <antcall target="test.public" inheritAll="false"/>
        <antcall target="integrationtest.public" inheritAll="false"/>
        <antcall target="pipelinetest.public" inheritAll="false"/>
    </target>

    <target name="releasetests.gatk.packagejar" depends="init.buildpublic,package">
        <antcall target="test.public" inheritAll="false">
            <param name="testng.classpath" value="testng.gatk.releasetest.classpath" />
        </antcall>
        <antcall target="integrationtest.public" inheritAll="false">
            <param name="testng.classpath" value="testng.gatk.releasetest.classpath" />
        </antcall>
    </target>

    <target name="releasetests.queue.packagejar" depends="init.buildpublic,queue">
        <antcall target="package" inheritAll="false">
            <param name="executable" value="Queue" />
        </antcall>
        <antcall target="pipelinetest.public" inheritAll="false">
            <param name="executable" value="Queue" />
            <param name="testng.classpath" value="testng.queue.releasetest.classpath" />
        </antcall>
    </target>

    <!-- Our four different test conditions: Test, IntegrationTest, LargeScaleTest, PipelineTest -->
    <target name="test" depends="init.buildall,test.compile,vcf.jar,test.init" description="Run unit tests">
        <condition property="ttype" value="*UnitTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${ttype}" outputdir="${report}/${ttype}" classpath="${testng.classpath}" runfailed="false"/>
    </target>
    <target name="test.public" depends="init.buildpublic,test"/>

    <target name="integrationtest" depends="init.buildall,test.compile,test.init" description="Run integration tests">
        <condition property="itype" value="*IntegrationTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${itype}" outputdir="${report}/${itype}" classpath="${testng.classpath}" runfailed="false"/>
    </target>
    <target name="integrationtest.public" depends="init.buildpublic,integrationtest"/>

    <target name="largescaletest" depends="init.buildall,test.compile,test.init" description="Run large-scale tests">
       <condition property="ptype" value="*LargeScaleTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${ptype}" outputdir="${report}/${ptype}" classpath="${testng.classpath}" runfailed="false"/>
    </target>
    <target name="largescaletest.public" depends="init.buildpublic,largescaletest" />

    <target name="pipelinetest" depends="init.buildall,test.compile,test.init" description="Run pipeline tests">
        <condition property="pipetype" value="*PipelineTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${pipetype}" outputdir="${report}/${pipetype}" classpath="${testng.classpath}" runfailed="false"/>
    </target>
    <target name="pipelinetest.public" depends="init.buildpublic,pipelinetest" />

    <target name="pipelinetestrun" depends="init.buildall,test.compile,test.init" description="Run pipeline tests">
        <property name="pipeline.run" value="run"/>
        <condition property="pipetype" value="*PipelineTest" else="${single}">
            <not><isset property="single"/></not>
        </condition>
        <run-test testtype="${pipetype}" outputdir="${report}/${pipetype}" classpath="${testng.classpath}" runfailed="false"/>
    </target>
    <target name="pipelinetestrun.public" depends="init.buildpublic,pipelinetestrun" />

    <target name="failed-test" depends="init.buildall,test.compile,test.init">
        <run-test testtype="${report}/*UnitTest/testng-failed.xml" outputdir="${report}/failed_rerun" classpath="${testng.classpath}" runfailed="true"/>
    </target>

    <target name="failed-integration" depends="init.buildall,test.compile,test.init">
        <run-test testtype="${report}/*IntegrationTest/testng-failed.xml" outputdir="${report}/failed_rerun" classpath="${testng.classpath}" runfailed="true"/>
    </target>

    <target name="failed-largescale" depends="init.buildall,test.compile,test.init">
        <run-test testtype="${report}/*LargeScaleTest/testng-failed.xml" outputdir="${report}/failed_rerun" classpath="${testng.classpath}" runfailed="true"/>
    </target>

    <target name="failed-pipeline" depends="init.buildall,test.compile,test.init">
        <run-test testtype="${report}/*PipelineTest/testng-failed.xml" outputdir="${report}/failed_rerun" classpath="${testng.classpath}" runfailed="true"/>
    </target>

    <!-- ******************************************************************************** -->
    <!-- Javadoc                                                                          -->
    <!-- ******************************************************************************** -->

    <target name="clean.javadoc">
        <delete dir="${javadoc.dir}" />
    </target>

    <target name="init.javadoc">
        <mkdir dir="${javadoc.dir}" />
    </target>

    <target name="javadoc" depends="init.buildpublic,generate.javadoc" description="Generates public javadoc" />

    <target name="javadoc.private" depends="init.buildall,generate.javadoc" description="Generates public and private javadoc" />

    <target name="generate.javadoc" depends="init.javadoc,resolve">
        <javadoc destdir="${javadoc.dir}" classpathref="external.dependencies">
            <fileset refid="java.source.files" />
            <sourcepath path="${external.dir}" />
        </javadoc>
    </target>

    <!-- ******************************************************************************** -->
    <!-- Scaladoc                                                                         -->
    <!-- ******************************************************************************** -->

    <target name="clean.scaladoc">
        <delete dir="${scaladoc.dir}" />
    </target>

    <target name="init.scaladoc">
        <mkdir dir="${scaladoc.dir}" />
    </target>

    <!-- NOTE: the scaladoc targets require that the environment variable ANT_OPTS has been set to "-Xmx1G" -->

    <target name="scaladoc" depends="init.buildpublic,generate.scaladoc" description="Generates public scaladoc -- set ANT_OPTS to -Xmx1G" />

    <target name="scaladoc.private" depends="init.buildall,generate.scaladoc" description="Generates public and private scaladoc -- set ANT_OPTS to -Xmx1G" />

    <target name="generate.scaladoc" depends="resolve,queue-extensions.generate,init.scala.compile,scala.compile,init.scaladoc">
        <scaladoc srcdir="${basedir}" destdir="${scaladoc.dir}" classpathref="scala.dependencies" deprecation="yes" unchecked="yes">
            <include name="${scala.public.source.dir}/**/*.scala" />
            <include name="${queue-extensions.source.dir}/**/*.scala" />
            <include name="${scala.private.source.dir}/**/*.scala" if="include.private" />
        </scaladoc>
    </target>

    <!-- ******************************************************************************** -->
    <!-- Release-related tasks                                                            -->
    <!-- ******************************************************************************** -->

    <!-- Unzip all classes from their current locations and assemble them in a staging directory -->
    <target name="stage" description="stage files for distribution">
        <mkdir dir="${staging.dir}"/>
        <!--
            HACK: Create the edu directory before EDU on case-insensitive mac filesystems.
            The ivy dependency colt -> concurrent contains an EDU.oswego package which
            BCEL doesn't even pull in but messes up edu.mit.broad.
          -->
        <mkdir dir="${staging.dir}/edu"/>
        <unjar dest="${staging.dir}" overwrite="false">
          <fileset dir="${dist.dir}">
            <patternset refid="dependency.mask" />
          </fileset>
        </unjar>

        <!-- HACK: The GATK jar itself contains overrides for some core classes.  Make sure the GATK.jar is unrolled last. -->
        <unjar dest="${staging.dir}" overwrite="true">
          <fileset dir="${dist.dir}" includes="**/GenomeAnalysisTK.jar"/>
        </unjar>
    </target>

    <!-- Build a package consisting of all supporting files -->
    <target name="package" depends="dist,stage" description="bundle up an executable for distribution">
      <mkdir dir="${package.output.dir}" />
      <xslt destdir="${package.output.dir}" style="${package.xml.dir}/CreatePackager.xsl" useImplicitFileset="false">
          <flattenmapper/>
          <fileset dir="${package.xml.dir}">
              <include name="${executable}.xml" />
          </fileset>

          <fileset dir="${external.dir}" erroronmissingdir="false">
              <include name="*/${executable}.xml" />
          </fileset>

      </xslt>
      <ant antfile="${package.output.dir}/${executable}.xml" target="package" />
    </target>

    <target name="release" depends="package" description="release a build, putting each file in a location specified by the package">
      <ant antfile="${package.output.dir}/${executable}.xml" target="release" />
    </target>

    <!-- Build a subset of picard with only those classes we need by completely abusing the packaging system -->
    <!-- TODO: Reuse as much as possible of the 'stage' and 'package' targets -->
    <target name="build-picard-private" depends="resolve">
      <!-- Build out a classpath -->
      <pathconvert property="required.picard.jars" pathsep=":">
        <fileset dir="${basedir}">
	     <include name="${staging.dir}" />
	     <include name="${lib.dir}/picard-*.*.*.jar" />
	     <include name="${lib.dir}/sam-*.jar" />
	   </fileset>
      </pathconvert>
      <echo message="required.picard.jars=${required.picard.jars}" />

      <!-- Stage picard-private -->
      <delete dir="${staging.dir}" />
      <mkdir dir="${staging.dir}" />
      <unjar src="${picard.dist.dir}/picard-private.jar" dest="${staging.dir}" overwrite="true" />

      <!-- Use the packaging system to extract parts of picard-private we need -->
      <mkdir dir="${package.output.dir}" />
      <xslt in="${package.xml.dir}/PicardPrivate.xml" out="${package.output.dir}/BuildPicardPrivate.xml" style="${package.xml.dir}/CreatePackager.xsl" />
      <ant antfile="${package.output.dir}/BuildPicardPrivate.xml">
	    <property name="additional.jars" value="${required.picard.jars}" />
      </ant>
    </target>

    <!-- ******************************************************************************** -->
    <!-- Find bug tasks                                                                   -->
    <!-- ******************************************************************************** -->
    <path id="findbugs.classpath">
      <fileset dir="${lib.dir}" erroronmissingdir="true" includes="*.jar"/>
    </path>
    <target         name="findbugs" depends="dist">
        <antcall    target  ="resolve">
            <param  name    ="ivy.conf" value="test"/>
        </antcall>
        <!-- setup the taskdef, telling ant where to find the defined task for ant -->
        <taskdef name="findbugs" classname="edu.umd.cs.findbugs.anttask.FindBugsTask" classpathref="findbugs.classpath"/>
        <!-- what should findbug look at: we want to aim it at the GATK.jar -->
        <findbugs       home="${findbugs.home}"
                        output="xml"
                        outputFile="${build.dir}/findbugs.xml"
                        classpathref="findbugs.classpath"
                        debug="false">
         <auxClasspath>
                <fileset dir="dist" includes="**/*.jar" excludes="**/GenomeAnalysisTK.jar"/>            
         </auxClasspath>
         <sourcePath    path="../java/src" />
         <class         location="dist/GenomeAnalysisTK.jar" />
       </findbugs>
    </target>

    <target name="clean" description="clean up" depends="clean.javadoc,clean.scaladoc,clean.gatkdocs">
        <delete dir="${build.dir}"/>
        <delete dir="${binaries.dir}"/>
        <delete dir="${lib.dir}"/>
        <delete dir="${contract.dump.dir}"/>
        <delete dir="${staging.dir}"/>
        <delete dir="${dist.dir}"/>
        <delete dir="${pipelinetest.dir}"/>
    </target>

    <!-- Build gsalib R module -->
    <target name="gsalib">
      <exec executable="R" failonerror="true">
        <arg line="R CMD INSTALL --preclean ${R.public.src.dir}/${R.package.path}/gsalib" />
      </exec>
    </target>

    <target name="clean.gsalib">
        <!-- Currently not cleaning out the lib during 'ant clean' -->
      <exec executable="R" failonerror="false">
        <arg line="R CMD REMOVE gsalib" />
      </exec>
    </target>

    <target name="binary.manifests" depends="sting.manifests">
        <jar id="files" jarfile="${binaries.dir}/SeqInCloud.jar">
            <zipfileset src="${dist.dir}/GenomeAnalysisTK.jar"/>
            <zipfileset src="${dist.dir}/StingUtils.jar"/>
            <zipfileset src="${lib.dir}/picard-1.59.1066.jar"/>
            <zipfileset src="${lib.dir}/sam-1.59.1066.jar"/>
            <zipfileset src="${lib.dir}/commons-cli-1.2.jar"/>
            <zipfileset src="${dist.dir}/vcf.jar"/>
            <manifest>
                <attribute name="Main-Class" value="org.broadinstitute.sting.gatk.hadoop.GATKJobClient"/>
            </manifest>
        </jar>

        <jar id="files" jarfile="${binaries.dir}/SICdeps.jar">
            <zipfileset src="${dist.dir}/AnalyzeCovariates.jar"/>
            <zipfileset src="${lib.dir}/tribble-53.jar"/>
            <zipfileset src="${lib.dir}/reflections-0.9.7.jar"/>
            <zipfileset src="${lib.dir}/google-collections-1.0.jar"/>
            <zipfileset src="${lib.dir}/dom4j-1.6.1.jar"/>
            <zipfileset src="${lib.dir}/javassist-3.12.1.GA.jar"/>
            <zipfileset src="${lib.dir}/colt-1.2.0.jar"/>
            <zipfileset src="${lib.dir}/commons-jexl-2.0.jar"/>
            <zipfileset src="${lib.dir}/log4j-1.2.15.jar"/>
            <zipfileset src="${lib.dir}/guava-12.0.jar"/>
        </jar>
    </target>
</project>
